import{_ as e,c as o,o as c,aR as d}from"./chunks/framework.DHENRzwb.js";const v=JSON.parse('{"title":"Git使用规范","description":"","frontmatter":{},"headers":[],"relativePath":"team-management/git.md","filePath":"team-management/git.md","lastUpdated":1726040701000}'),t={name:"team-management/git.md"},p=d('<h1 id="git使用规范" tabindex="-1">Git使用规范 <a class="header-anchor" href="#git使用规范" aria-label="Permalink to &quot;Git使用规范&quot;">​</a></h1><h2 id="前置条件" tabindex="-1">前置条件 <a class="header-anchor" href="#前置条件" aria-label="Permalink to &quot;前置条件&quot;">​</a></h2><ul><li>这里设定每个项目的主(生产)分支都是develop</li></ul><h2 id="克隆一个新仓库" tabindex="-1">克隆一个新仓库 <a class="header-anchor" href="#克隆一个新仓库" aria-label="Permalink to &quot;克隆一个新仓库&quot;">​</a></h2><p><code>git clone 项目地址 本地文件夹名(可选)</code></p><p><img src="https://felbry.github.io/picx-images-hosting/image.8vmuy45y0p.webp" alt="image"></p><h2 id="基于远程develop分支-创建-本地develop分支" tabindex="-1">基于远程develop分支 创建 本地develop分支 <a class="header-anchor" href="#基于远程develop分支-创建-本地develop分支" aria-label="Permalink to &quot;基于远程develop分支 创建 本地develop分支&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>对于分支，首先要搞清楚<strong>远程</strong>和<strong>本地</strong>的区别。</p><p>本地是本地的（只有<code>push</code>操作才能将本地的内容推送保存到远程）</p><p>远程是远程的（只有<code>fetch</code>，<code>pull</code>操作才能将远程的内容拉取到本地）</p><p>因此，最佳实践就是：本地分支A对应<code>push</code>和<code>pull</code>远程分支A，这样就能建立<strong>一对一的映射效果</strong>；而不要把本地分支A<code>push</code>到远程分支B上去。</p></div><p>首先运行<code>git branch</code>，看下刚clone下来的项目有没有<strong>本地分支</strong></p><p><img src="https://felbry.github.io/picx-images-hosting/image.1lbrn33nn5.webp" alt="image"></p><p>可以看到，默认有一个<code>main</code>的本地分支。可以理解为在clone动作时，就基于远程的<code>main</code>分支创建了对应的本地<code>main</code>分支。（有的项目可能是<code>master</code>，这取决于创建git仓库时所用的git版本，对于这个默认初始分支名称，低版本是<code>master</code>，高版本是<code>main</code>）</p><p>运行<code>git branch -a</code>，可以看到<strong>本地分支</strong>和<strong>远程分支</strong>。（远程分支都是 remotes/origin 开头的）</p><p><img src="https://felbry.github.io/picx-images-hosting/image.39l4ka9mge.webp" alt="image"></p><div class="info custom-block"><p class="custom-block-title">基于远程分支创建本地分支分两步</p><p>第一切换到远程分支，第二从中检出。</p></div><blockquote><ol><li>切换到远程分支</li></ol></blockquote><p><code>git checkout remotes/origin/develop</code></p><p><img src="https://felbry.github.io/picx-images-hosting/image.92q2tl5n90.webp" alt="image"></p><blockquote><ol start="2"><li>从中检出</li></ol></blockquote><p><code>git checkout -b develop</code></p><p><img src="https://felbry.github.io/picx-images-hosting/image.2krv09wk1c.webp" alt="image"></p><p>此时再运行<code>git branch</code>，可以看到已有远程develop分支对应的本地develop分支了，且当前正处于该分支上。</p><p><img src="https://felbry.github.io/picx-images-hosting/image.6ik8gy8zzz.webp" alt="image"></p><h2 id="重点-必读-分支命名规范" tabindex="-1">[重点/必读] 分支命名规范 <a class="header-anchor" href="#重点-必读-分支命名规范" aria-label="Permalink to &quot;[重点/必读] 分支命名规范&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">规范1：分支分隔符</p><p>分支名要表明是从哪个分支检出，<code>@</code>的作用就是分隔父和子。</p></div><p><strong>PS：早期规范是用<code>-</code>分隔父和子，但是存在两个问题：</strong></p><ol><li>分隔效果不太明显</li><li>当子分支名存在多个单词时仅能用小驼峰命名格式，不得不引入大写字母，如果用<code>@</code>的话，子分支名的多个单词就可以用<code>-</code>分割了</li></ol><div class="warning custom-block"><p class="custom-block-title">为什么不用<code>/</code>分隔</p><p>会报<code>fatal: cannot lock ref &#39;refs/heads/develop/&lt;desc&gt;.&lt;name&gt;.&lt;date&gt;&#39;: &#39;refs/heads/develop&#39; exists; cannot create &#39;refs/heads/develop/&lt;desc&gt;.&lt;name&gt;.&lt;date&gt;&#39;</code>。也就是说可以创建<code>feat/xxx</code>，<code>hotfix/xxx</code>这样的分支，但不能创建<code>feat/xxx/kkk</code>这样的分支，会造成refs冲突。</p></div><p>比如生产分支是<code>develop</code>，基于生产开发就是<code>develop@feat-a</code>，<code>develop@feat-b</code>。如果<code>feat-b</code>后面又需要加人开发，那这个新人应该起一个<code>develop@feat-b@my-desc</code>的新分支。</p><p><strong>分支的层级最大应该控制在4级以内，大多数需求2～3级就够。过深的层级应该考虑下是否有必要。</strong></p><div class="tip custom-block"><p class="custom-block-title">规范2：分支说明信息</p><p>业务分支还需要加上 创建人员姓名缩写 以及 创建时间(MMDD格式) 的信息。这些信息统一用<code>.</code>来修饰</p><p>而特殊/长期分支无需这些信息</p></div><p>比如小明要开发一个修改姓名的功能，他的分支应该叫：<code>develop@modify-name.xm.0909</code>。这是一个日常开发业务的分支，所以应该包含创建者名缩写和时间。</p><p>而一些特殊的场景，比如用于长期部署测试环境，分支名叫<code>develop@test</code>，就无需包含这些信息。</p><h2 id="创建自己的分支" tabindex="-1">创建自己的分支 <a class="header-anchor" href="#创建自己的分支" aria-label="Permalink to &quot;创建自己的分支&quot;">​</a></h2><p>上面已经提到过，从当前分支检出一条新分支的命令是：<code>git checkout -b 新分支名</code>。</p><p>假设当前位于本地develop分支上，我的名字叫小明，要开发一个个人中心页面，就可以执行<code>git checkout -b develop@personal-page.xm.0909</code></p><h2 id="重点-必读-分支合并规范" tabindex="-1">[重点/必读] 分支合并规范 <a class="header-anchor" href="#重点-必读-分支合并规范" aria-label="Permalink to &quot;[重点/必读] 分支合并规范&quot;">​</a></h2><p>当你在做合并时，考虑下有没有<strong>严格遵守</strong>这几条规范：</p><ol><li>仅且只有你一人在操作的分支，可以随意的<code>push</code>或<code>pull</code></li></ol><p>比如上面例子：<code>develop@personal-page.xm.0909</code>。这个分支已经声明是小明在9月9日创建的要开发个人中心的分支，仅且只有小明一人会操作它，小明就可以自由的对该分支<code>push</code>或<code>pull</code>，不会影响他人</p><ol start="2"><li>2人+的合作分支，不允许在本地<code>push</code>，<code>merge</code>，仅能<code>pull</code></li></ol><p>拿<code>develop</code>生产分支举例，任何人的代码最终都要合进来，这就算是一个2人+的合作分支。</p><p>🚫 不能在本地<code>develop</code>上，执行<code>git push origin develop</code>操作</p><p>🚫 不能在本地<code>develop</code>上，执行<code>git merge 其它分支</code>操作</p><p>✅ 可以在本地<code>develop</code>上，执行<code>git pull origin develop</code>拉取远程最新的代码（由于你没有在本地对该合作分支进行过任何更新，因此这个<code>pull</code>动作永远不会出现冲突）</p><div class="info custom-block"><p class="custom-block-title">向合作分支合并的标准流程</p><p>以<code>develop@personal-page.xm.0909</code>向<code>develop</code>合并为例：</p><ol><li>先在本地<code>develop@personal-page.xm.0909</code>上，执行<code>git push origin develop@personal-page.xm.0909</code></li><li>在Gitlab项目主页，发起“New Merge Request”，Source branch选<code>develop@personal-page.xm.0909</code>，Target branch选<code>develop</code>，接着下一步</li><li>此时分有冲突和没有冲突两种情况：没有冲突可以直接完成合并，有冲突按如下方式解决：</li></ol><p>当有冲突时，关闭当前Merge Request。本地分支切换到<code>develop</code>，执行<code>git pull origin develop</code>；然后本地分支切换到<code>develop@personal-page.xm.0909</code>，执行<code>git merge develop</code>。此时就能看到有冲突的文件。修改所有有冲突的文件，依次执行<code>git add .</code>、<code>git commit -m 解决冲突</code>。最后继续按上述步骤1、2、3来执行即可。</p></div><div class="tip custom-block"><p class="custom-block-title">总结</p><p>在实际应用中，<code>develop@personal-page.xm.0909</code>类比你的个人开发分支，<code>develop</code>类比2人+的合作分支，举一反三即可。</p></div><h3 id="特殊场景的合并-单向合并" tabindex="-1">特殊场景的合并（单向合并） <a class="header-anchor" href="#特殊场景的合并-单向合并" aria-label="Permalink to &quot;特殊场景的合并（单向合并）&quot;">​</a></h3><p>按照我们的分支管理规范，每个人拥有自己的分支，各自开发各自的，互不干扰。</p><p>但也有这样的特殊场景：在一个时间范围内，小红开发功能A，小明开发功能B，此时都需要部署测试环境。如果部署小红的分支，就会覆盖掉小明的，反之一样。</p><p>我们需要一个新临时分支来包含小红、小明、...的功能以便测试。由于目的很明确，我们可以统一叫<code>develop@test</code>分支。它的名字表示是从<code>develop</code>检出的为了测试的分支。</p><div class="danger custom-block"><p class="custom-block-title">为什么单独讲这种合并呢？</p><p>由于<code>develop@test</code>的特殊性，在合并时仅且只能执行单向合并。你的分支可以随意合并到<code>develop@test</code>（合坏了大不了再删掉重建它），但万不可将<code>develop@test</code>合并到你的分支。</p><p>我们举一个具体的场景：</p><p>小红开发功能A，小明开发功能B，它俩都会合并到<code>develop@test</code>以便测试。</p><p>临近上线，产品要求功能B不上线了，如果小红和小明都按照标准管理分支，此时只需要把小红的功能A分支合并进生产分支即可。</p><p>但是如果没有按照要求，小红在测试过程中，自己的分支还不小心合并了<code>develop@test</code>，那她自己的功能A分支也会包含小明的功能B代码，就没办法解耦了。</p></div><p>向<code>develop@test</code>合并的步骤按照标准流程的1～3步走即可。只是在解决冲突时略有不同。</p><p>以<code>develop@feat-a.xh.0909</code>向<code>develop@test</code>合并发生冲突为例：</p><p>切换到本地分支<code>develop@test</code>，执行<code>git pull origin develop@test</code>，执行<code>git merge develop@feat-a.xh.0909</code>，此时就能看到有冲突的文件。修改所有有冲突的文件，依次执行<code>git add .</code>、<code>git commit -m 解决冲突</code>、<code>git push origin develop@test</code>。</p>',54),l=[p];function a(i,s,r,g,n,m){return c(),o("div",null,l)}const u=e(t,[["render",a]]);export{v as __pageData,u as default};
