import{_ as i,c as a,a4 as e,o as t}from"./chunks/framework.07rp2gkU.js";const c=JSON.parse('{"title":"Docker 配置私有仓库","description":"","frontmatter":{},"headers":[],"relativePath":"docker/private-registry.md","filePath":"docker/private-registry.md","lastUpdated":1731047365000}'),n={name:"docker/private-registry.md"};function l(p,s,r,h,o,d){return t(),a("div",null,s[0]||(s[0]=[e(`<h1 id="docker-配置私有仓库" tabindex="-1">Docker 配置私有仓库 <a class="header-anchor" href="#docker-配置私有仓库" aria-label="Permalink to &quot;Docker 配置私有仓库&quot;">​</a></h1><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>阿里云购买的 2 核 2GiB 的服务器，由于内存过小，构建比较大的镜像时机器就会卡死</p><p>可以通过在服务器配置私有仓库，本地打包再推送到私有仓库的形式</p><p>其实也可以本地打包镜像后，导出通过 rsync 等方式传到服务端，再由服务端的 docker daemon load 这个镜像文件。但这种方式没有推送 registry 快。如果镜像是 1g，每次都要推送 1g；而 registry 可以缓存 layer 提升后续的传输速度</p></div><h2 id="_1-安装启动-docker-registry" tabindex="-1">1. 安装启动 Docker Registry <a class="header-anchor" href="#_1-安装启动-docker-registry" aria-label="Permalink to &quot;1. 安装启动 Docker Registry&quot;">​</a></h2><p>略</p><h2 id="_2-测试-registry-服务是否正常" tabindex="-1">2. 测试 registry 服务是否正常 <a class="header-anchor" href="#_2-测试-registry-服务是否正常" aria-label="Permalink to &quot;2. 测试 registry 服务是否正常&quot;">​</a></h2><p>访问<code>http://&lt;ip&gt;:&lt;port&gt;/v2/_catalog</code>，一般会得到如下响应：</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;repositories&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: []</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li><code>port</code>默认是<code>5000</code></li><li>记得配置服务器的安全组开放该端口</li></ul><h2 id="_3-构建推送第一个镜像" tabindex="-1">3. 构建推送第一个镜像 <a class="header-anchor" href="#_3-构建推送第一个镜像" aria-label="Permalink to &quot;3. 构建推送第一个镜像&quot;">​</a></h2><p>构建 <code>docker build -t &lt;ip&gt;:&lt;port&gt;/&lt;image-name&gt;</code>，tag 的组成参见：<a href="./base.html#给镜像打-tag">Docker 入门 - 给镜像打 Tag</a></p><p>推送 <code>docker push &lt;ip&gt;:&lt;port&gt;/&lt;image-name&gt;</code></p><p>此时访问<code>http://&lt;ip&gt;:&lt;port&gt;/v2/_catalog</code>，得到如下响应：</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;repositories&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&lt;image-name&gt;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>一开始推送，会报如下错误：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">The</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> push</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> refers</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> to</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> repository</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [&lt;ip&gt;:&lt;port&gt;/&lt;image-name&gt;]</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Get</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;https://&lt;ip&gt;:&lt;port&gt;/v2/&quot;:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> http:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> server</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> gave</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> HTTP</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> response</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> to</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> HTTPS</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> client</span></span></code></pre></div><p>需要配置<code>daemon.json</code>，将私有仓库的地址追加进<code>insecure-registries</code>中（非 https 访问的可视为不安全的地址）</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;insecure-registries&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;&lt;ip&gt;:&lt;port&gt;&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div></div><h2 id="_4-服务端运行镜像" tabindex="-1">4. 服务端运行镜像 <a class="header-anchor" href="#_4-服务端运行镜像" aria-label="Permalink to &quot;4. 服务端运行镜像&quot;">​</a></h2><p>提前做两个步骤：</p><ul><li>1panel - 容器 - 仓库，配置私有仓库地址（主要指定协议和用户名、密码，这样拉取时就不需要询问）</li><li>1panel - 容器 - 配置 - 私有仓库，它对应 <code>daemon.json</code> 中的 <code>insecure-registries</code></li></ul><p>任意位置创建<code>docker-compose.yaml</code>文件，<code>image</code>指定为<code>127.0.0.1:&lt;port&gt;/&lt;image-name&gt;</code>，然后执行<code>docker compose up</code></p><h2 id="_5-加入用户认证" tabindex="-1">5. 加入用户认证 <a class="header-anchor" href="#_5-加入用户认证" aria-label="Permalink to &quot;5. 加入用户认证&quot;">​</a></h2><p>按照<a href="https://distribution.github.io/distribution/about/deploying/#native-basic-auth" target="_blank" rel="noreferrer">Deploy a registry server -&gt; Native basic auth</a>的前两条警示，要实现用户名和密码登录，必须先配置 TLS。因为不能以明文来传递这些数据</p><h3 id="_5-1-配置-tls" tabindex="-1">5.1 配置 TLS <a class="header-anchor" href="#_5-1-配置-tls" aria-label="Permalink to &quot;5.1 配置 TLS&quot;">​</a></h3><p>根据<a href="https://distribution.github.io/distribution/about/deploying/#get-a-certificate" target="_blank" rel="noreferrer">Deploy a registry server -&gt; Get a certificate</a>的描述，我们需要做两步：</p><ol><li>获得证书，即<code>.crt</code>文件和<code>.key</code>文件</li><li>通过<code>docker run</code>运行容器，主要传递<code>REGISTRY_HTTP_TLS_CERTIFICATE</code>、<code>REGISTRY_HTTP_TLS_KEY</code>这俩变量</li></ol><p>这里参考<a href="./../1panel/https.html">使用 1panel 申请/续签 HTTPS 证书</a>和<a href="./../1panel/reverse-proxy.html">使用 1panel 创建 HTTPS 服务</a>做一个 https 代理即可。没有必要从 registry 层面配置</p><h3 id="_5-2-配置用户名、密码" tabindex="-1">5.2 配置用户名、密码 <a class="header-anchor" href="#_5-2-配置用户名、密码" aria-label="Permalink to &quot;5.2 配置用户名、密码&quot;">​</a></h3><p>前置条件：当前处于 docker registry 的编排目录<code>/opt/1panel/apps/docker-registry/docker-registry</code></p><p><img src="https://felbry.github.io/picx-images-hosting/image.5mntkyhexu.webp" alt="image"></p><p>此时运行：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  --entrypoint</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> htpasswd</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  httpd:2</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -Bbn</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> testuser</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> testpassword</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> auth/htpasswd</span></span></code></pre></div><p>生成一个<code>auth</code>文件夹，其下有个<code>htpasswd</code>文件，文件中有一个：用户名：testuser、密码：testpassword 的账号</p><p>这里不用<code>docker run</code>运行，而是编排的形式。因此参考<a href="https://distribution.github.io/distribution/about/deploying/#deploy-your-registry-using-a-compose-file" target="_blank" rel="noreferrer">Deploy your registry using a Compose file</a>，对 registry 的 compose 文件增加如下内容：</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark has-diff vp-code" tabindex="0"><code><span class="line diff add"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">environment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span></span>
<span class="line diff add"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  REGISTRY_AUTH</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">htpasswd</span></span>
<span class="line diff add"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  REGISTRY_AUTH_HTPASSWD_PATH</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/auth/htpasswd</span></span>
<span class="line diff add"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  REGISTRY_AUTH_HTPASSWD_REALM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Registry Realm</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">volumes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line diff add"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  - </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">./auth:/auth</span></span></code></pre></div><ul><li>由于把<code>auth</code>目录创建在了和 compose 文件同级的目录下，所以 volume 的挂载路径就是<code>./auth</code></li></ul><p>重启 compose，此时访问<code>https://&lt;domain-name&gt;/v2/_catalog</code>就需要输入账号密码了</p><h3 id="_5-3-试试推送和拉取" tabindex="-1">5.3 试试推送和拉取 <a class="header-anchor" href="#_5-3-试试推送和拉取" aria-label="Permalink to &quot;5.3 试试推送和拉取&quot;">​</a></h3><p>直接运行<code>docker push &lt;domain-name&gt;/&lt;image-name&gt;</code>，会报<code>no basic auth credentials</code>的错误，此时只需要执行<code>docker login &lt;domain-name&gt;</code>，输入用户名、密码，即可登录成功。之后就能正常推送了</p><blockquote><p>如果该 registry 服务是通过 openresty 或 nginx 代理的，推送的镜像某个 layer 过大会报：<code>413 Request Entity Too Large</code>的错误，此时需要在 openresty 或 nginx 的配置文件中增加一行：</p></blockquote><div class="language-nginx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">nginx</span><pre class="shiki shiki-themes github-light github-dark has-diff vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">server</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line diff add"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  client_max_body_size </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1024M</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>对于服务器内部想要拉取镜像，先通过<code>docker login 127.0.0.1:&lt;port&gt;</code>登录，或是直接在 1panel -&gt; 容器 -&gt; 仓库 来配置用户名、密码</p><h3 id="ps-不建议自签名证书方案" tabindex="-1">PS：不建议自签名证书方案 <a class="header-anchor" href="#ps-不建议自签名证书方案" aria-label="Permalink to &quot;PS：不建议自签名证书方案&quot;">​</a></h3><p>按照文档<a href="https://distribution.github.io/distribution/about/insecure/#use-self-signed-certificates" target="_blank" rel="noreferrer">Test an insecure registry - Use self-signed certificates</a>所述，你需要做：</p><ol><li>首先通过<code>openssl</code>生成一个自己的证书文件</li><li>重新运行 registry，指向证书文件</li><li>根据你的操作系统，配置 docker daemon 去信任该证书</li><li>[可选]使用身份认证时，某些 Docker 还要求信任操作系统级别的证书</li></ol><p>与其这样麻烦，在有域名的前提下，不如申请证书走正规配置，能省去 3、4 以及后续步骤</p><h2 id="附-配置-registry" tabindex="-1">附：<a href="https://distribution.github.io/distribution/about/configuration/" target="_blank" rel="noreferrer">配置 registry</a> <a class="header-anchor" href="#附-配置-registry" aria-label="Permalink to &quot;附：[配置 registry](https://distribution.github.io/distribution/about/configuration/)&quot;">​</a></h2><p>一种是部分配置，比如<code>REGISTRY_AUTH</code>、<code>REGISTRY_AUTH_HTPASSWD_PATH</code></p><p>一种是全量覆盖配置</p><p>文档里都有详尽说明该如何配置</p><h2 id="其它" tabindex="-1">其它 <a class="header-anchor" href="#其它" aria-label="Permalink to &quot;其它&quot;">​</a></h2><p>也可以通过该方式实现镜像加速：<a href="https://www.wanpeng.life/2826.html" target="_blank" rel="noreferrer">https://www.wanpeng.life/2826.html</a></p>`,49)]))}const g=i(n,[["render",l]]);export{c as __pageData,g as default};
