import{_ as i,c as s,o as e,a8 as a}from"./chunks/framework.CR3ACB_j.js";const g=JSON.parse('{"title":"Docker 入门","description":"","frontmatter":{},"headers":[],"relativePath":"docker/base.md","filePath":"docker/base.md","lastUpdated":1729588655000}'),t={name:"docker/base.md"},o=a(`<h1 id="docker-入门" tabindex="-1">Docker 入门 <a class="header-anchor" href="#docker-入门" aria-label="Permalink to &quot;Docker 入门&quot;">​</a></h1><h2 id="常用命令" tabindex="-1">常用命令 <a class="header-anchor" href="#常用命令" aria-label="Permalink to &quot;常用命令&quot;">​</a></h2><ul><li><code>docker run &lt;IMAGE_NAME&gt;</code> 基于指定镜像创建运行一个容器</li><li><code>docker ps</code> 查看正在运行的容器。<code>-a</code> 包含停止的容器</li><li><code>docker stop &lt;the-container-id&gt;</code> 停止运行容器。<code>the-container-id</code>可以截取部分，保证唯一性即可。比如<code>a1f7a4bb3a27</code>简写为<code>a1f</code></li><li><code>docker image ls</code> 查看本地（已下载/已构建）镜像。简写<code>docker images</code></li><li><code>docker image history &lt;IMAGE_NAME&gt;</code> 查看该镜像每一 layer 信息</li><li><code>docker tag &lt;DOCKER_USERNAME&gt;/demo &lt;DOCKER_USERNAME&gt;/demo:1.0</code></li><li><code>docker push &lt;DOCKER_USERNAME&gt;/demo:1.0</code></li></ul><h2 id="架构和相关概念" tabindex="-1">架构和相关概念 <a class="header-anchor" href="#架构和相关概念" aria-label="Permalink to &quot;架构和相关概念&quot;">​</a></h2><p>采用 C/S 架构</p><p><img src="https://docs.docker.com/get-started/images/docker-architecture.webp" alt=""></p><h3 id="服务端-dockerd" tabindex="-1">服务端 <code>dockerd</code> <a class="header-anchor" href="#服务端-dockerd" aria-label="Permalink to &quot;服务端 \`dockerd\`&quot;">​</a></h3><p>Docker daemon，守护进程，一方面接收客户端的 API 请求，一方面管理 Docker 对象(images、containers、networks、volumes)</p><h3 id="客户端-docker" tabindex="-1">客户端 <code>docker</code> <a class="header-anchor" href="#客户端-docker" aria-label="Permalink to &quot;客户端 \`docker\`&quot;">​</a></h3><p><code>docker run</code>等命令都是由客户端发起的，客户端通过 API 调用服务端，由<code>dockerd</code>执行</p><p>客户端可以与多个服务端（守护进程）通信</p><h3 id="docker-desktop" tabindex="-1">Docker Desktop <a class="header-anchor" href="#docker-desktop" aria-label="Permalink to &quot;Docker Desktop&quot;">​</a></h3><p>包含了<code>dockerd</code>、<code>docker</code>、Docker Compose、Docker Content Trust、Kubernetes...</p><h3 id="docker-registries" tabindex="-1">Docker Registries <a class="header-anchor" href="#docker-registries" aria-label="Permalink to &quot;Docker Registries&quot;">​</a></h3><p>负责存储 Docker 镜像。Docker Hub 类比 <code>npmjs.com</code>，同理 registry 也可以配置为私有的</p><h3 id="docker-compose" tabindex="-1">Docker Compose <a class="header-anchor" href="#docker-compose" aria-label="Permalink to &quot;Docker Compose&quot;">​</a></h3><p>用于运行管理多个容器。</p><p>虽然可以通过<code>docker run</code>启动多个容器，但是马上就会遇到网络管理、连接网络以及清理工作等许多麻烦的事。使用 Docker Compose 这种声明式工具，只需要定义<code>compose.yml</code>文件，在其中定义所有容器及其配置即可</p><h3 id="docker-objects" tabindex="-1">Docker Objects <a class="header-anchor" href="#docker-objects" aria-label="Permalink to &quot;Docker Objects&quot;">​</a></h3><p>images、containers、networks、volumes、plugins 都可以叫 Docker objects</p><h3 id="images-镜像" tabindex="-1">images 镜像 <a class="header-anchor" href="#images-镜像" aria-label="Permalink to &quot;images 镜像&quot;">​</a></h3><p>镜像是用来 创建 container 的<strong>只读</strong>模板（包含运行容器所需的文件、库和配置）</p><p>通常一个镜像会基于其它镜像，并进行一些自定义。比如可以构建一个基于<code>ubuntu</code>镜像，并安装<code>Apache web server</code>和其它<code>application</code>，再附带<code>application</code>运行所需的详细配置的镜像</p><p>创建一个镜像：创建一个 Dockerfile，定义创建并运行它所需的步骤。（每条指令都会创建一个 layer，更改并重建镜像时，也只会重建已更改的 layer）</p><div class="info custom-block"><p class="custom-block-title"><a href="https://docs.docker.com/get-started/docker-concepts/the-basics/what-is-an-image/#explanation" target="_blank" rel="noreferrer">两大原则</a></p><ol><li><p>镜像不可变。镜像一旦创建就无法修改，只能<strong>创建一个新镜像</strong>或<strong>在其之上添加更改</strong></p></li><li><p>每个镜像由 layers 组成。每个 layer 代表一组添加、删除或修改文件的文件系统更改</p></li></ol></div><p><a href="https://docs.docker.com/get-started/docker-concepts/building-images/understanding-image-layers/" target="_blank" rel="noreferrer">了解 layer</a>：</p><ul><li><p>先通过一个示例，解释“每个 layer 代表一组添加、删除或修改文件的文件系统更改”：</p><p>创建一个镜像从零开始考虑：假设当前是一个纯净的 ubuntu 系统，什么东西都没有，极端点想，该磁盘只有一个空空的根目录：<code>/</code>，要让程序代码运行，需要配置若干环境</p><ul><li>第 1 layer，先添加基本命令和包管理工具（比如 apt）</li><li>第 2 layer，安装 Python 运行时和 pip</li><li>第 3 layer，复制应用程序运行所需的必要文件（比如 requirements.txt）</li><li>第 4 layer，通过 pip 安装应用程序的依赖</li><li>第 5 layer，复制应用程序源码</li></ul><p><img src="https://docs.docker.com/get-started/docker-concepts/building-images/images/container_image_layers.webp" alt=""></p><p>每组文件系统更改都抽象成 layer，便可以跨镜像复用。</p><p><img src="https://docs.docker.com/get-started/docker-concepts/building-images/images/container_image_layer_reuse.webp" alt=""></p><p>这样<code>Debian base</code>和<code>Python and pip</code>layer 就可以被多个镜像引用了，而不用构建多个</p></li><li><p>堆叠 layers</p><ol><li>每个 layer 下载后，被提取到主机文件系统上对应的目录里</li><li>每从镜像运行一个新容器时，会创建一个独立的、全新的<strong>联合文件系统(union filesystem)</strong>。该镜像的每个 layer 就基于这个 union filesystem 逐个操作</li><li>容器启动时，使用<code>chroot</code>将其环境根目录设置为 union filesystem 的位置</li></ol><p>PS：文档中提到 当创建 union filesystem 时，除了镜像 layers，还会创建一个目录为正在运行的容器服务。允许容器进行文件系统更改，同时也能保证原始图像层保持不变。（这和我上边理解的好像有些差异，我理解的是这个目录等于 union filesystem，后续结合实践再看看）</p></li><li><p>追加 layer 实操</p><p>先基于 ubuntu 镜像创建一个名为 base-container 的容器，<code>docker run --name=base-container -ti ubuntu</code></p><p>在容器中安装 Node.js <code>apt update &amp;&amp; apt install -y nodejs</code> （文件更改发生在该容器的 union filesystem 中）</p><p>将 base-container 容器 构建为新镜像 node-base <code>docker container commit -m &quot;Add node&quot; base-container node-base</code></p><p>[可选] 此时查看镜像 node-base 的历史，就会看到刚追加进的 layer</p><p>再基于 node-base 镜像创建一个名为 app-container 的容器，<code>docker run --name=app-container -ti node-base</code></p><p>在容器中创建一个 app.js 文件 <code>echo &#39;console.log(&quot;Hello from an app&quot;)&#39; &gt; app.js</code>（文件更改发生在该容器的 union filesystem 中）</p><p>将 app-container 容器构建为新镜像 sample-app <code>docker container commit -c &quot;CMD node app.js&quot; -m &quot;Add app&quot; app-container sample-app</code></p><p>[可选] 此时查看镜像 sample-app 的历史，就会看到刚追加进的 layer</p></li></ul><p><a href="https://docs.docker.com/get-started/docker-concepts/building-images/writing-a-dockerfile/" target="_blank" rel="noreferrer">编写 Dockerfile</a></p><p><a href="https://docs.docker.com/reference/dockerfile/" target="_blank" rel="noreferrer">指令参考</a></p><ul><li><code>FROM &lt;IMAGE_NAME&gt;</code> 指定基础镜像，必须位于第一行，后面可以跟一个可选的镜像标签</li><li><code>WORKDIR &lt;PATH&gt;</code> 设置工作目录。（我觉得可以理解为<code>cd</code>）</li><li><code>COPY &lt;HOST_PATH&gt; &lt;IMAGE_PATH&gt;</code> 复制文件或目录到镜像，支持相对路径和绝对路径。</li><li><code>RUN &lt;COMMAND&gt;</code> 运行一条命令</li><li><code>ENV &lt;NAME&gt; &lt;VALUE&gt;</code> 设置环境变量（适用于正在运行的容器）</li><li><code>EXPOSE &lt;PORT&gt;</code> 暴露端口，让外部可以访问</li><li><code>USER &lt;USER-OR-UID&gt;</code> 为后续指令设置用户</li><li><code>CMD [&quot;&lt;command&gt;&quot;, &quot;&lt;arg1&gt;&quot;]</code> 设置基于此镜像的容器运行时自动执行的命令。示例：<code>CMD [&quot;uvicorn&quot;, &quot;app.main:app&quot;, &quot;--host&quot;, &quot;0.0.0.0&quot;, &quot;--port&quot;, &quot;8080&quot;]</code></li></ul><h3 id="containers-容器" tabindex="-1">containers 容器 <a class="header-anchor" href="#containers-容器" aria-label="Permalink to &quot;containers 容器&quot;">​</a></h3><p>容器是镜像的可运行实例</p><p>可以创建、启动/停止、移动或删除容器</p><p>可以将容器连接到一个或多个网络，为其附加存储</p><p>甚至可以根据容器当前状态创建一个新镜像</p><p><strong>隔离性</strong>：容器与其它容器、操作系统都有相对较好的隔离。当然也可以手动控制容器的网络、存储、与主机关系的隔离程度</p><p>容器的配置选项取决于创建和启动它时对应的镜像，如果<strong>删除容器，任何未存储在持久存储中的状态更改都会消失</strong></p><h2 id="使用容器进行开发" tabindex="-1">使用容器进行开发 <a class="header-anchor" href="#使用容器进行开发" aria-label="Permalink to &quot;使用容器进行开发&quot;">​</a></h2><p>克隆 Demo 工程：<code>git clone https://github.com/docker/getting-started-todo-app</code></p><p>在工程目录下执行<code>docker compose watch</code>，访问 <code>http://localhost</code></p><p>之后无论是修改前端还是后端代码，网站都是实时更新</p><div class="info custom-block"><p class="custom-block-title">总结</p><p>容器化环境提供了统一的开发环境，每个人无需安装 Node、MySQL 或其它依赖项。</p></div><h2 id="构建并推送第一个镜像" tabindex="-1">构建并推送第一个镜像 <a class="header-anchor" href="#构建并推送第一个镜像" aria-label="Permalink to &quot;构建并推送第一个镜像&quot;">​</a></h2><p>先在<a href="https://hub.docker.com/" target="_blank" rel="noreferrer">Docker Hub</a>创建一个仓库，仓库名为 getting-started-todo-app</p><p>在项目根目录先构建：<code>docker build -t &lt;DOCKER_USERNAME&gt;/getting-started-todo-app .</code></p><p>然后运行<code>docker image ls</code>查看本地镜像是否构建成功</p><p>最后推送到远程：<code>docker push &lt;DOCKER_USERNAME&gt;/getting-started-todo-app</code></p><h2 id="问题" tabindex="-1">问题 <a class="header-anchor" href="#问题" aria-label="Permalink to &quot;问题&quot;">​</a></h2><ol><li><code>Error response from daemon: Get &quot;https://registry-1.docker.io/v2/&quot;</code></li></ol><p>外网的 docker hub 访问不通，通过配置 daemon 代理访问。参考<a href="https://docs.docker.com/reference/cli/dockerd/#daemon-configuration-file" target="_blank" rel="noreferrer">daemon configuration file</a>、<a href="https://docs.docker.com/engine/daemon/proxy/#httphttps-proxy" target="_blank" rel="noreferrer">http/https proxy</a></p><p>mac 版配置如图：（参考<a href="https://s.v2ex.com/t/1056546#r_14982082" target="_blank" rel="noreferrer">请问大佬， MacOS 下如何设置 docker 使用本地代理？ - v2ex</a>）</p><p><img src="https://felbry.github.io/picx-images-hosting/image.9rje8kv6hg.webp" alt="image"></p><ol start="2"><li><code>ERROR [client internal] load metadata for docker.io/library/node:20</code></li></ol><p>在按照官网教程操作<a href="#使用容器进行开发">使用容器进行开发</a>时，报了这个错误，完整情况如下：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">%</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> compose</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> watch</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[+] Building 31.2s (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">4/4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) FINISHED                                         docker:desktop-linux</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; [backend </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">internal]</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> load</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> build</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> definition</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Dockerfile</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                              0.0s</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> transferring</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> dockerfile:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 3.30kB</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                                                    0.0s</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; [client </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">internal]</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> load</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> build</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> definition</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Dockerfile</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                               0.0s</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> transferring</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> dockerfile:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 3.30kB</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                                                    0.0s</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">ERROR</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [client </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">internal]</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> load</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> metadata</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> for</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> docker.io/library/node:20</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                  31.1s</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; [backend </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">auth]</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> library/node:pull</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> token</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> for</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> registry-1.docker.io</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                       0.0s</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">------</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [client internal] </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">load</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> metadata</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> for</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> docker.io/library/node:20:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">------</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">failed</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> to</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> solve:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> DeadlineExceeded:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> DeadlineExceeded:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> DeadlineExceeded:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> node:20:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> failed</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> to</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> resolve</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> source</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> metadata</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> for</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> docker.io/library/node:20:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> failed</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> to</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> authorize:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> DeadlineExceeded:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> failed</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> to</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> fetch</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> oauth</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> token:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Post</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;https://auth.docker.io/token&quot;:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> dial</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> tcp</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 108.160.172.204:443:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> i/o</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> timeout</span></span></code></pre></div><p>该问题尚未解决，后续学到更多知识再分析</p>`,56),l=[o];function n(r,p,d,k,h,c){return e(),s("div",null,l)}const E=i(t,[["render",n]]);export{g as __pageData,E as default};
