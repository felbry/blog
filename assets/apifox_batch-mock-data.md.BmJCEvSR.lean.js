import{_ as i,c as e,a4 as o,o as p}from"./chunks/framework.07rp2gkU.js";const l=JSON.parse('{"title":"Apifox 批量模拟数据","description":"","frontmatter":{},"headers":[],"relativePath":"apifox/batch-mock-data.md","filePath":"apifox/batch-mock-data.md","lastUpdated":1750901503000}'),a={name:"apifox/batch-mock-data.md"};function s(g,t,c,r,d,m){return p(),e("div",null,t[0]||(t[0]=[o('<h1 id="apifox-批量模拟数据" tabindex="-1">Apifox 批量模拟数据 <a class="header-anchor" href="#apifox-批量模拟数据" aria-label="Permalink to &quot;Apifox 批量模拟数据&quot;">​</a></h1><p>在 Apifox 中，批量发起请求的<strong>第一步</strong>是“先创建一个接口”，如图所示：</p><p><img src="https://felbry.github.io/picx-images-hosting/image.64e4e768ib.webp" alt="image"></p><p>从图中可知：</p><ul><li>接口定义了<strong>body 的参数值</strong><code>id</code>从<strong>环境变量</strong><code>myId</code>中取（双大括号包裹就是变量的写法）</li><li>采用“示例”的模式，能快速将已有的 JSON 数据复制进来（如果采用“数据结构”的模式，要一个一个配字段，很麻烦）</li></ul><p><strong>第二步</strong>就是“批量发起该接口”，如图所示：</p><p><img src="https://felbry.github.io/picx-images-hosting/image.9kgg6aatfk.webp" alt="image"></p><p>在运行之前，我们还需要一项额外设置，点击上图<strong>第 2 步</strong>添加的接口，进入编辑页面，如图所示：</p><p><img src="https://felbry.github.io/picx-images-hosting/image.sz7ti5bu0.webp" alt="image"></p><p>在“自动生成”下拉框中，有很多选项。这些选项决定了你请求发起时“模拟数据是怎么生成的”。其中前几项适合“数据结构”的配置模式，由于最开始图省事采用了“示例”的模式，因此这里也要选择“使用请求示例”，最后全部保存。</p><p>此时，你可以批量运行 10 次看看效果（先不使用测试数据）</p><p><img src="https://felbry.github.io/picx-images-hosting/image.2rvejuhle0.webp" alt="image"></p><div><p>你会看到，在没有测试数据的情况下，实际请求发起的 Body 参数值就是固定的{{myId}}，因为此时环境里还没有<code>myId</code>这个变量</p></div><p>接下来就<strong>使用测试数据</strong>批量生成<code>myId</code>这个变量</p><h2 id="从-csv-中批量导入" tabindex="-1">从 CSV 中批量导入 <a class="header-anchor" href="#从-csv-中批量导入" aria-label="Permalink to &quot;从 CSV 中批量导入&quot;">​</a></h2><p>首先选中<strong>测试数据</strong>，并点击<strong>新建</strong></p><p><img src="https://felbry.github.io/picx-images-hosting/image.sz7uewbew.webp" alt="image"></p><p><img src="https://felbry.github.io/picx-images-hosting/image.5c18xe2tnw.webp" alt="image"></p><p>CSV 的数据如下图，它只有一列，列头名称为<code>ID</code>：</p><p><img src="https://felbry.github.io/picx-images-hosting/image.2vf0igyuuf.webp" alt="image"></p><p>导入 Apifox 的效果如下：</p><p><img src="https://felbry.github.io/picx-images-hosting/image.4jodfnqakj.webp" alt="image"></p><p>可以看到，除了<code>ID</code>列，最前面还自动生成了一列“数据集名称”，这个“数据集名称”可以理解为一条数据的唯一标识。</p><p>比如第一行，就是名叫“数据集-1”的这条数据包含了一个变量<code>ID</code>，值为<code>00616c24-866c-46d5-b7bc-ac5...</code>。（你可以继续添加列 2（变量 2），列 3（变量 3），这样一条数据就可以有多个变量了）</p><div class="tip custom-block"><p class="custom-block-title">注意</p><p>列头标题其实就是<strong>变量名称</strong></p><p>在接口中，我们定义的是取<code>myId</code>这个变量值。因此，要将导入的列头<code>ID</code>改为<code>myId</code></p></div><p>数据准备好后，就可以<strong>运行</strong>了，如下图所示，关联已创建的测试数据，循环次数根据测试数据的条数自动计算：</p><p><img src="https://felbry.github.io/picx-images-hosting/image.8dx4ymn6j7.webp" alt="image"></p><p><img src="https://felbry.github.io/picx-images-hosting/image.8ojyrs30kp.webp" alt="image"></p><p>在运行二次确认弹窗中，也可以<strong>只勾选部分数据</strong>，这里“数据集名称”的作用就体现出来了，它可以让你快速找到你想要使用的数据。</p><p>我们只勾选前 5 条，点击运行，结果如下：</p><p><img src="https://felbry.github.io/picx-images-hosting/image.b965umme8.webp" alt="image"></p><p>可以看到，变量<code>myId</code>已经被替换为对应的测试数据</p><div class="danger custom-block"><p class="custom-block-title">注意一处错误</p><p>上图中，Body 的<code>id</code>值前后缺少了引号，不是正确的字符串格式</p><p>因此，接口定义中的<span>&quot;id&quot;: {{myId}}</span>要写成<span>&quot;id&quot;: &quot;{{myId}}&quot;</span>才行</p></div>',33)]))}const b=i(a,[["render",s]]);export{l as __pageData,b as default};
